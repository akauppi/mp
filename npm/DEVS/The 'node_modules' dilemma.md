# The `node_modules` dilemma...

## Problem

Multipass mounts (as of 1.15.1 and quite some time before) have a problem with large folders with lots of (small) files.

The way the author eradicates this problem in Rust is by pointing the dependencies and build artifacts to live on the local VM filesystem, instead of the shared mount. Cargo can use a `target-dir = ...` config for this.

No such "luck" with `npm`.


## World view of `npm`

Whereas `node` can be told where its dependencies are (by `NODE_PATH` env.var), `npm` does not follow this. 

- it *does* have a "global mode", but that's a) meant for other kind of use, b) didn't fare well as a work-around
- it *does* have "workspaces", but a) the author wasn't familiar with them (lame reason) and b) they aim to solve a different problem, not that of directing separate projects' dependencies to a global place

Cut the story short, there emerged a workable solution!

## Fast track to solution

Within the VM, *replace* the (mounted) `node_modules` folder by *another mount*, within the VM, this time. See here:

```
$ sudo mount -t tmpfs -o size=500m,uid=1000 abc node_modules
```

```
$ mkdir ../node_modules.ABC
$ sudo mount --bind ../node_modules.ABC node_modules
```

The first one uses `tmpfs`, making a memory partition. It's fast, but the changes (`npm install`) don't survive over a VM restart.

The second one is equally performant, and the changes remain in place.

>Note: However, as we'll mention below, the *mount* does not survive over a VM restart.


## The aims of the author

I'd like to ignore this problem.

In particular, I'd like the version controlled files *not* to reflect there is a problem.

This means, if you're developing the code on, say, a native Linux account, you shouldn't see clutter due to some Multipass-on-Mac-only issue.

Furthermore, if you weren't reading this text, things would still *work*, they just work really, really slow (see below for numbers..).


## Things considered

### Symbolic link of `node_modules`

Nope. `npm` observes it, prints out "non-directory blah-blah replaced", and carries on with the link gone and a local `node_modules` folder created (which is slow).

That's *one* way to deal with it.


### Alternative package managers...?

Yeah, I gave `pnpm` a try. Just... don't really like it enough. And there's nothing *really* wrong with `npm`.

So uninstalled it. But if you like `pnpm`, you're likely to not have this whole problem, at all.


## Positive side effects

Having `node_module` carry different contents for your (host side) IDE and the VM is a Good Thing. It avoids the stepping-on-toes of binary modules, where the IDE could install a macOS variant that the Linux-side VM then dislikes. For each, their own.


<!--R The execution gotcha was fixed by adding 'exec' option to '/etc/fstab'

## Gotchas

Looking at ways to persist the mounts over VM restarts, `/etc/fstab` is the place and mechanism. This involves appending a line to said file:

```
/home/ubuntu/.node_modules/436a40d8 /home/ubuntu/my-app/node_modules none user,bind,noauto,rw,relatime,discard,commit=30
```

Restart the service by:

```
$ sudo systemctl daemon-reload
```

This is NOT perfect.

For **SOME WILD REASON** mounts done via this mechanism are different from mere `sudo mount --bind` as mentioned above.

When `/etc/fstab` is involved, whether with `sudo mount` or sudo-less, the mount does work but `npm` doesn't work with the mount, giving:

```
$ npm install

npm error code 1
npm error path /home/ubuntu/npm_plain/my-app/node_modules/esbuild
npm error command failed
npm error command sh -c node install.js
npm error node:internal/child_process:1120
npm error     result.error = new ErrnoException(result.error, 'spawnSync ' + options.file);
npm error                    ^
npm error
npm error <ref *1> Error: spawnSync /home/ubuntu/npm_plain/my-app/node_modules/esbuild/bin/esbuild EACCES
npm error     at Object.spawnSync (node:internal/child_process:1120:20)
npm error     at spawnSync (node:child_process:878:24)
npm error     at Object.execFileSync (node:child_process:921:15)
npm error     at validateBinaryVersion (/home/ubuntu/npm_plain/my-app/node_modules/esbuild/install.js:101:28)
npm error     at /home/ubuntu/npm_plain/my-app/node_modules/esbuild/install.js:285:5 {
npm error   errno: -13,
npm error   code: 'EACCES',
npm error   syscall: 'spawnSync /home/ubuntu/npm_plain/my-app/node_modules/esbuild/bin/esbuild',
npm error   path: '/home/ubuntu/npm_plain/my-app/node_modules/esbuild/bin/esbuild',
npm error   spawnargs: [ '--version' ],
npm error   error: [Circular *1],
npm error   status: null,
npm error   signal: null,
npm error   output: null,
npm error   pid: 0,
npm error   stdout: undefined,
npm error   stderr: undefined
npm error }
npm error
npm error Node.js v24.1.0
npm error A complete log of this run can be found in: /home/ubuntu/.npm/_logs/2025-06-20T17_25_41_644Z-debug-0.log
```

When this happens, the contents are:

```
node_modules/.bin/
├── acorn -> ../acorn/bin/acorn
├── esbuild -> ../esbuild/bin/esbuild
├── nanoid -> ../nanoid/bin/nanoid.cjs
├── rollup -> ../rollup/dist/bin/rollup
├── svelte-check -> ../svelte-check/bin/svelte-check
├── svelte-kit -> ../@sveltejs/kit/svelte-kit.js
├── tsc -> ../typescript/bin/tsc
├── tsserver -> ../typescript/bin/tsserver
├── uuid -> ../uuid/dist/esm/bin/uuid
└── vite -> ../vite/bin/vite.js
```

`node_modules` itself is empty, so the links above are broken. 

The author has no knowledge how to counteract this. If you know, please share. I'd love the recurring mount to be simply:

```
# within each project
$ mount node_modules
```

instead of:

```
$ sudo mount --bind ~/.node_modules/{id} node_modules
```
-->

## Appendix A. Data

Performance should not be based on gut feelings. Here's my data.

- macOS 15.3
- Multipass 1.15.0
- ..with native mounts for the project folder

- Node 22
- `npm` 10.9.2


**Default (native mount; `node_modules` as part of it)**

- clean `npm install`: 

	```
	real	3m27.706s
	user	0m53.000s
	sys		1m23.645s
	```

	Yeah, 3 minutes and some.
	
- `du -h -d 1 node_modules` (after filled):

	```
	real	0m23.772s
	user	0m0.048s
	sys		0m2.795s	
	```
	
	>Note: The discrepancy between CPU time (2.8s) and wall clock time (24s) is... tremendous! Perhaps that can be a cue to what's (not) going on, there.
	
- `npm run dev`: 

	```
	ready in 43842 ms
	```

**`mount -t tmpfs`**

- clean `npm install`: 

	```
	real	1m11.513s
	user	0m27.387s
	sys		0m23.473s
	```
	
- `du -h -d 1 node_modules` (after filled):

	```
	real	0m0.139s
	user	0m0.043s
	sys		0m0.095s	
	```
	
- `npm run dev`: 

	```
	ready in 3979 ms
	```
	<!-- 2nd run: 3480 ms -->

**`mount --bind`**

- clean `npm install`: 

	```
	real	1m14.670s
	user	0m31.036s
	sys		0m23.502s
	```
	
- `du -h -d 1 node_modules` (after filled):

	```
	real	0m0.109s
	user	0m0.036s
	sys		0m0.073s
	```
	
- `npm run dev`: 

	```
	ready in 3359 ms
	```
	<!-- 2nd run: 3320 -->

**as a table**

||`npm run dev`|
|---|---|
|default|43..44s|
|`tmpfs`|3.5 .. 3.9s|
|`mount --bind`|3.2 .. 3.4s|

