# The `node_modules` dilemma...

## Problem

Multipass mounts (as of 0.15.0 and quite some time before) have a problem with large folders with lots of (small) files.

The way the author eradicates this problem in Rust is by pointing the dependencies and build artifacts to live on the local VM filesystem, instead of the shared mount. Cargo can use a `target-dir = ...` config for this.

No such "luck" with `npm`.

## World view of `npm`

Whereas `node` can be told where its dependencies are (by `NODE_PATH` env.var), `npm` does not follow this. 

- it *does* have a "global mode", but that's a) meant for other kind of use, b) didn't fare well as a work-around
- it *does* have "workspaces", but a) the author wasn't familiar with them (lame reason) and b) they aim to solve a different problem, not that of directing separate projects' dependencies to a global place

Cut the story short, there emerged a workable solution!

## Fast track to solution

Within the VM, *replace* the (mounted) `node_modules` folder by *another mount*, within the VM, this time. See here:

```
$ sudo mount -t tmpfs -o size=500m,uid=1000 abc node_modules
```

```
$ mkdir ../node_modules.ABC
$ sudo mount --bind ../node_modules.ABC node_modules
```

The first one uses `tmpfs`, making a memory partition. It's fast, but the changes (`npm install`) don't survive over a VM restart.

The second one is equally performant, and the changes remain in place.


## The aims of the author

I'd like to ignore this problem.

In particular, I'd like the version controlled files *not* to reflect there is a problem.

This means, if you're developing the code on, say, a native Linux account, you shouldn't see clutter due to some Multipass-on-Mac-only issue.

Furthermore, if you weren't reading this text, things would still *work*, they just work really, really slow (see below for numbers..).

Thus, the above instructions on mapping might be enough. At least they point you in the right direction.


## Things considered

### Symbolic link of `node_modules`

Nope. `npm` observes it, prints out "non-directory blah-blah replaced", and carries on with the link gone and a local `node_modules` folder created (which is slow).

That's *one* way to deal with it.


### Alternative package managers...?

Yeah, I gave `pnpm` a try. Just... don't really like it enough. And there's nothing *really* wrong with `npm`.

So uninstalled it. But if you like `pnpm`, you're likely to not have this whole problem, at all.


## Gotchas

Now that the work-around (VM-internal-mount) is in place, what's the harm?

Your host IDE will see different contents in `node_modules` than your VM. Just be aware of this.

Note that having them both update the *same folder* would anyways be hazardous, since e.g. in my case, the host runs macOS and the VM is Linux. Some Node packages build differently and you'll get errors.


## Future

I wonder... what will happen if I point *all* my Node/`npm` projects (in the same VM) to use the same folder. I might do this!

In Rust, this is the way I do, and there it happens to work. It really depends on package manager internals, whether there are problems. I am not going to be working *simultaneously* on multiple projects, anyhow, which might be enough to please things. 

The benefit? Less file system use, especially if the same dependencies are being used (e.g. Vite etc. for SvelteKit).

<!-- error when `node_modules` has macOS stuff in it:

$ npm run dev

> pulu@0.0.0 dev
> vite dev

/home/ubuntu/Pulu/node_modules/rollup/dist/native.js:64
		throw new Error(
		      ^

Error: Cannot find module @rollup/rollup-linux-x64-gnu. npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). Please try `npm i` again after removing both package-lock.json and node_modules directory.
    at requireWithFriendlyError (/home/ubuntu/Pulu/node_modules/rollup/dist/native.js:64:9)
    at Object.<anonymous> (/home/ubuntu/Pulu/node_modules/rollup/dist/native.js:73:76)
    at Module._compile (node:internal/modules/cjs/loader:1723:14)
    at Object..js (node:internal/modules/cjs/loader:1888:10)
    at Module.load (node:internal/modules/cjs/loader:1458:32)
    at Function._load (node:internal/modules/cjs/loader:1275:12)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:234:24)
    at cjsLoader (node:internal/modules/esm/translators:311:5)
    at ModuleWrap.<anonymous> (node:internal/modules/esm/translators:204:7) {
  [cause]: Error: Cannot find module '@rollup/rollup-linux-x64-gnu'
-->


---

## Data

Performance should not be based on gut feelings. Here's my data.

- macOS 15.3
- Multipass 1.15.0
- ..with native mounts for the project folder

- Node 22
- `npm` 10.9.2


**Default (native mount; `node_modules` as part of it)**

- clean `npm install`: 

	```
	real	3m27.706s
	user	0m53.000s
	sys		1m23.645s
	```

	Yeah, 3 minutes and some.
	
- `du -h -d 1 node_modules` (after filled):

	```
	real	0m23.772s
	user	0m0.048s
	sys		0m2.795s	
	```
	
	>Note: The discrepancy between CPU time (2.8s) and wall clock time (24s) is... tremendous! Perhaps that can be a cue to what's (not) going on, there.
	
- `npm run dev`: 

	```
	ready in 43842 ms
	```

**`mount -t tmpfs`**

- clean `npm install`: 

	```
	real	1m11.513s
	user	0m27.387s
	sys		0m23.473s
	```
	
- `du -h -d 1 node_modules` (after filled):

	```
	real	0m0.139s
	user	0m0.043s
	sys		0m0.095s	
	```
	
- `npm run dev`: 

	```
	ready in 3979 ms
	```
	<!-- 2nd run: 3480 ms -->

**`mount --bind`**

- clean `npm install`: 

	```
	real	1m14.670s
	user	0m31.036s
	sys		0m23.502s
	```
	
- `du -h -d 1 node_modules` (after filled):

	```
	real	0m0.109s
	user	0m0.036s
	sys		0m0.073s
	```
	
- `npm run dev`: 

	```
	ready in 3359 ms
	```
	<!-- 2nd run: 3320 -->

**as a table**

||`npm run dev`|
|---|---|
|default|43..44s|
|`tmpfs`|3.5 .. 3.9s|
|`mount --bind`|3.2 .. 3.4s|

